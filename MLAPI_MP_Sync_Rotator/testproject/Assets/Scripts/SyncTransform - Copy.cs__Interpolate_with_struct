using MLAPI.NetworkVariable;
using UnityEngine;

namespace MLAPI
{
    /// <summary>
    /// A component for syncing variables
    /// Initial goal: allow an FPS-style snapshot
    /// with variables updating at specific place in the frame
    /// </summary>
    [AddComponentMenu("MLAPI/SyncTransform")]
    // todo: check inheriting from NetworkBehaviour. Currently needed for IsOwner, to synchronize position
    public class SyncTransform : NetworkBehaviour
    {
        private NetworkVariable<State> m_VarState = new NetworkVariable<State>();
        private const float k_Epsilon = 0.0001f;

        private bool m_Interpolate = true;
        public double interpolationBackTime = 0.1; 

        internal struct State
        {
            internal double timestamp;
            internal Vector3 pos;
            internal Quaternion rot;
        }
        // We store twenty states with "playback" information
        State[] m_BufferedState = new State[20];
        // Keep track of what slots are used
	    int m_TimestampCount;

        public SyncTransform()
        {
            for(int v = 0; v < m_BufferedState.Length; ++v)
            {
                m_BufferedState[v].timestamp = -1.0f;
            }
        }

        void SyncTransformChanged(State before, State after)
        {
            if (IsClient)
            {
                if(m_Interpolate)
                {
                    // Receive latest state information
                    Vector3 pos = Vector3.zero;
                    Quaternion rot = Quaternion.identity;
                    
                    // Shift buffer contents, oldest data erased, 18 becomes 19, ... , 0 becomes 1
                    for (int v = m_BufferedState.Length - 1; v > 0; --v)
                    {
                        m_BufferedState[v] = m_BufferedState[v-1];
                    }
                    
                    // Save currect received state as 0 in the buffer, safe to overwrite after shifting
                    State state;
                    state.timestamp = after.timestamp;
                    state.pos = after.pos;
                    state.rot = after.rot;
                    m_BufferedState[0] = state;
                    
                    // Increment state count but never exceed buffer size
                    m_TimestampCount = Mathf.Min(m_TimestampCount + 1, m_BufferedState.Length);

                    // Check integrity, lowest numbered state in the buffer is newest and so on
                    for (int v = 0; v < m_TimestampCount - 1; v++)
                    {
                        if (m_BufferedState[v].timestamp < m_BufferedState[v+1].timestamp)
                            Debug.Log("State inconsistent");
                    }
                }
                else
                {
                    gameObject.transform.position = after.pos;
                    gameObject.transform.rotation = after.rot;
                }
            }
        }

        void Start()
        {
            m_VarState.Settings.WritePermission = NetworkVariablePermission.ServerOnly;
        }

        void FixedUpdate()
        {
            // if this.gameObject is local let's send its position
            if (IsServer)
            {
                State newState;
                newState.timestamp = NetworkManager.NetworkTime;
                newState.pos = gameObject.transform.position;
                newState.rot = gameObject.transform.rotation;
                m_VarState.Value = newState;
            }
            else
            {
                if (!m_Interpolate)
                {
                    return;
                }

                double currentTime = NetworkManager.NetworkTime;
                double interpolationTime = currentTime - interpolationBackTime;
                // We have a window of interpolationBackTime where we basically play 
                // By having interpolationBackTime the average ping, you will usually use interpolation.
                // And only if no more data arrives we will use extrapolation
                
                // Use interpolation
                // Check if latest state exceeds interpolation time, if this is the case then
                // it is too old and extrapolation should be used
                if (m_BufferedState[0].timestamp > interpolationTime)
                {
                    for (int v = 0; v < m_TimestampCount; v++)
                    {
                        // Find the state which matches the interpolation time (time+0.1) or use last state
                        if (m_BufferedState[v].timestamp <= interpolationTime || v == m_TimestampCount-1)
                        {
                            // The state one slot newer (<100ms) than the best playback state
                            State rhs = m_BufferedState[Mathf.Max(v-1, 0)];
                            // The best playback state (closest to 100 ms old (default time))
                            State lhs = m_BufferedState[v];
                            
                            // Use the time between the two slots to determine if interpolation is necessary
                            double length = rhs.timestamp - lhs.timestamp;
                            float t = 0.0F;
                            // As the time difference gets closer to 100 ms t gets closer to 1 in 
                            // which case rhs is only used
                            if (length > k_Epsilon)
                                t = (float)((interpolationTime - lhs.timestamp) / length);
                            
                            // if t=0 => lhs is used directly
                            transform.localPosition = Vector3.Lerp(lhs.pos, rhs.pos, t);
                            transform.localRotation = Quaternion.Slerp(lhs.rot, rhs.rot, t);
                            return;
                        }
                    }
                }
                // Use extrapolation. Here we do something really simple and just repeat the last
                // received state. You can do clever stuff with predicting what should happen.
                else
                {
                    State latest = m_BufferedState[0];
                    
                    transform.localPosition = latest.pos;
                    transform.localRotation = latest.rot;
                }
            }
        }
    }
}
